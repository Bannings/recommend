// Code generated by protoc-gen-go. DO NOT EDIT.
// source: division.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DivisionStatus int32

const (
	DivisionStatus_SUCCEED DivisionStatus = 0
	DivisionStatus_FAILED  DivisionStatus = 1
)

var DivisionStatus_name = map[int32]string{
	0: "SUCCEED",
	1: "FAILED",
}

var DivisionStatus_value = map[string]int32{
	"SUCCEED": 0,
	"FAILED":  1,
}

func (x DivisionStatus) String() string {
	return proto.EnumName(DivisionStatus_name, int32(x))
}

func (DivisionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{0}
}

type DivisionGender int32

const (
	DivisionGender_MALE   DivisionGender = 0
	DivisionGender_FEMALE DivisionGender = 1
)

var DivisionGender_name = map[int32]string{
	0: "MALE",
	1: "FEMALE",
}

var DivisionGender_value = map[string]int32{
	"MALE":   0,
	"FEMALE": 1,
}

func (x DivisionGender) String() string {
	return proto.EnumName(DivisionGender_name, int32(x))
}

func (DivisionGender) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{1}
}

type User struct {
	Udid                 string         `protobuf:"bytes,1,opt,name=Udid,proto3" json:"Udid,omitempty"`
	Uid                  int64          `protobuf:"varint,2,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Version              string         `protobuf:"bytes,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Channel              string         `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Gender               DivisionGender `protobuf:"varint,5,opt,name=Gender,proto3,enum=proto.DivisionGender" json:"Gender,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{0}
}

func (m *User) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_User.Unmarshal(m, b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_User.Marshal(b, m, deterministic)
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return xxx_messageInfo_User.Size(m)
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetUdid() string {
	if m != nil {
		return m.Udid
	}
	return ""
}

func (m *User) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *User) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *User) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *User) GetGender() DivisionGender {
	if m != nil {
		return m.Gender
	}
	return DivisionGender_MALE
}

type CoverDivision struct {
	Cover                string               `protobuf:"bytes,1,opt,name=Cover,proto3" json:"Cover,omitempty"`
	Passthrough          *DivisionPassthrough `protobuf:"bytes,2,opt,name=Passthrough,proto3" json:"Passthrough,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CoverDivision) Reset()         { *m = CoverDivision{} }
func (m *CoverDivision) String() string { return proto.CompactTextString(m) }
func (*CoverDivision) ProtoMessage()    {}
func (*CoverDivision) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{1}
}

func (m *CoverDivision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CoverDivision.Unmarshal(m, b)
}
func (m *CoverDivision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CoverDivision.Marshal(b, m, deterministic)
}
func (m *CoverDivision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoverDivision.Merge(m, src)
}
func (m *CoverDivision) XXX_Size() int {
	return xxx_messageInfo_CoverDivision.Size(m)
}
func (m *CoverDivision) XXX_DiscardUnknown() {
	xxx_messageInfo_CoverDivision.DiscardUnknown(m)
}

var xxx_messageInfo_CoverDivision proto.InternalMessageInfo

func (m *CoverDivision) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *CoverDivision) GetPassthrough() *DivisionPassthrough {
	if m != nil {
		return m.Passthrough
	}
	return nil
}

type DivisionPassthrough struct {
	ExpId                string   `protobuf:"bytes,1,opt,name=ExpId,proto3" json:"ExpId,omitempty"`
	BucketId             string   `protobuf:"bytes,2,opt,name=BucketId,proto3" json:"BucketId,omitempty"`
	BucketName           string   `protobuf:"bytes,3,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
	Uid                  int64    `protobuf:"varint,4,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Udid                 string   `protobuf:"bytes,5,opt,name=Udid,proto3" json:"Udid,omitempty"`
	AlgId                string   `protobuf:"bytes,6,opt,name=AlgId,proto3" json:"AlgId,omitempty"`
	ServeTime            int64    `protobuf:"varint,7,opt,name=ServeTime,proto3" json:"ServeTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DivisionPassthrough) Reset()         { *m = DivisionPassthrough{} }
func (m *DivisionPassthrough) String() string { return proto.CompactTextString(m) }
func (*DivisionPassthrough) ProtoMessage()    {}
func (*DivisionPassthrough) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{2}
}

func (m *DivisionPassthrough) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DivisionPassthrough.Unmarshal(m, b)
}
func (m *DivisionPassthrough) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DivisionPassthrough.Marshal(b, m, deterministic)
}
func (m *DivisionPassthrough) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DivisionPassthrough.Merge(m, src)
}
func (m *DivisionPassthrough) XXX_Size() int {
	return xxx_messageInfo_DivisionPassthrough.Size(m)
}
func (m *DivisionPassthrough) XXX_DiscardUnknown() {
	xxx_messageInfo_DivisionPassthrough.DiscardUnknown(m)
}

var xxx_messageInfo_DivisionPassthrough proto.InternalMessageInfo

func (m *DivisionPassthrough) GetExpId() string {
	if m != nil {
		return m.ExpId
	}
	return ""
}

func (m *DivisionPassthrough) GetBucketId() string {
	if m != nil {
		return m.BucketId
	}
	return ""
}

func (m *DivisionPassthrough) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *DivisionPassthrough) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DivisionPassthrough) GetUdid() string {
	if m != nil {
		return m.Udid
	}
	return ""
}

func (m *DivisionPassthrough) GetAlgId() string {
	if m != nil {
		return m.AlgId
	}
	return ""
}

func (m *DivisionPassthrough) GetServeTime() int64 {
	if m != nil {
		return m.ServeTime
	}
	return 0
}

type CoverDivisionResponse struct {
	ResponseStatus       DivisionStatus `protobuf:"varint,1,opt,name=ResponseStatus,proto3,enum=proto.DivisionStatus" json:"ResponseStatus,omitempty"`
	Massage              string         `protobuf:"bytes,2,opt,name=Massage,proto3" json:"Massage,omitempty"`
	Data                 *CoverDivision `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CoverDivisionResponse) Reset()         { *m = CoverDivisionResponse{} }
func (m *CoverDivisionResponse) String() string { return proto.CompactTextString(m) }
func (*CoverDivisionResponse) ProtoMessage()    {}
func (*CoverDivisionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{3}
}

func (m *CoverDivisionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CoverDivisionResponse.Unmarshal(m, b)
}
func (m *CoverDivisionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CoverDivisionResponse.Marshal(b, m, deterministic)
}
func (m *CoverDivisionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoverDivisionResponse.Merge(m, src)
}
func (m *CoverDivisionResponse) XXX_Size() int {
	return xxx_messageInfo_CoverDivisionResponse.Size(m)
}
func (m *CoverDivisionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CoverDivisionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CoverDivisionResponse proto.InternalMessageInfo

func (m *CoverDivisionResponse) GetResponseStatus() DivisionStatus {
	if m != nil {
		return m.ResponseStatus
	}
	return DivisionStatus_SUCCEED
}

func (m *CoverDivisionResponse) GetMassage() string {
	if m != nil {
		return m.Massage
	}
	return ""
}

func (m *CoverDivisionResponse) GetData() *CoverDivision {
	if m != nil {
		return m.Data
	}
	return nil
}

type MultiCoverDivision struct {
	ComicID              int32                `protobuf:"varint,1,opt,name=ComicID,proto3" json:"ComicID,omitempty"`
	Cover                string               `protobuf:"bytes,2,opt,name=Cover,proto3" json:"Cover,omitempty"`
	Passthrough          *DivisionPassthrough `protobuf:"bytes,3,opt,name=Passthrough,proto3" json:"Passthrough,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MultiCoverDivision) Reset()         { *m = MultiCoverDivision{} }
func (m *MultiCoverDivision) String() string { return proto.CompactTextString(m) }
func (*MultiCoverDivision) ProtoMessage()    {}
func (*MultiCoverDivision) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{4}
}

func (m *MultiCoverDivision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MultiCoverDivision.Unmarshal(m, b)
}
func (m *MultiCoverDivision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MultiCoverDivision.Marshal(b, m, deterministic)
}
func (m *MultiCoverDivision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiCoverDivision.Merge(m, src)
}
func (m *MultiCoverDivision) XXX_Size() int {
	return xxx_messageInfo_MultiCoverDivision.Size(m)
}
func (m *MultiCoverDivision) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiCoverDivision.DiscardUnknown(m)
}

var xxx_messageInfo_MultiCoverDivision proto.InternalMessageInfo

func (m *MultiCoverDivision) GetComicID() int32 {
	if m != nil {
		return m.ComicID
	}
	return 0
}

func (m *MultiCoverDivision) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *MultiCoverDivision) GetPassthrough() *DivisionPassthrough {
	if m != nil {
		return m.Passthrough
	}
	return nil
}

type MultiCoverDivisionResponse struct {
	ResponseStatus       DivisionStatus        `protobuf:"varint,1,opt,name=ResponseStatus,proto3,enum=proto.DivisionStatus" json:"ResponseStatus,omitempty"`
	Massage              string                `protobuf:"bytes,2,opt,name=Massage,proto3" json:"Massage,omitempty"`
	Data                 []*MultiCoverDivision `protobuf:"bytes,3,rep,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MultiCoverDivisionResponse) Reset()         { *m = MultiCoverDivisionResponse{} }
func (m *MultiCoverDivisionResponse) String() string { return proto.CompactTextString(m) }
func (*MultiCoverDivisionResponse) ProtoMessage()    {}
func (*MultiCoverDivisionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f675e9d1cd0eb12, []int{5}
}

func (m *MultiCoverDivisionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MultiCoverDivisionResponse.Unmarshal(m, b)
}
func (m *MultiCoverDivisionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MultiCoverDivisionResponse.Marshal(b, m, deterministic)
}
func (m *MultiCoverDivisionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiCoverDivisionResponse.Merge(m, src)
}
func (m *MultiCoverDivisionResponse) XXX_Size() int {
	return xxx_messageInfo_MultiCoverDivisionResponse.Size(m)
}
func (m *MultiCoverDivisionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiCoverDivisionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MultiCoverDivisionResponse proto.InternalMessageInfo

func (m *MultiCoverDivisionResponse) GetResponseStatus() DivisionStatus {
	if m != nil {
		return m.ResponseStatus
	}
	return DivisionStatus_SUCCEED
}

func (m *MultiCoverDivisionResponse) GetMassage() string {
	if m != nil {
		return m.Massage
	}
	return ""
}

func (m *MultiCoverDivisionResponse) GetData() []*MultiCoverDivision {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.DivisionStatus", DivisionStatus_name, DivisionStatus_value)
	proto.RegisterEnum("proto.DivisionGender", DivisionGender_name, DivisionGender_value)
	proto.RegisterType((*User)(nil), "proto.User")
	proto.RegisterType((*CoverDivision)(nil), "proto.CoverDivision")
	proto.RegisterType((*DivisionPassthrough)(nil), "proto.DivisionPassthrough")
	proto.RegisterType((*CoverDivisionResponse)(nil), "proto.CoverDivisionResponse")
	proto.RegisterType((*MultiCoverDivision)(nil), "proto.MultiCoverDivision")
	proto.RegisterType((*MultiCoverDivisionResponse)(nil), "proto.MultiCoverDivisionResponse")
}

func init() { proto.RegisterFile("division.proto", fileDescriptor_3f675e9d1cd0eb12) }

var fileDescriptor_3f675e9d1cd0eb12 = []byte{
	// 501 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xed, 0xd6, 0x76, 0xda, 0x8c, 0x45, 0x14, 0x86, 0x14, 0x99, 0xa8, 0x42, 0xc1, 0x07, 0x64,
	0x2a, 0xb5, 0x07, 0x73, 0x05, 0x89, 0x60, 0x9b, 0xc8, 0xa8, 0x41, 0x95, 0x43, 0xb8, 0x9b, 0x78,
	0x94, 0x58, 0xc4, 0x76, 0x64, 0x3b, 0x11, 0x67, 0x7e, 0x80, 0x3b, 0x5c, 0xf9, 0x11, 0xfe, 0x0c,
	0x79, 0x77, 0x1d, 0x27, 0x6d, 0x8a, 0xc4, 0x81, 0x53, 0xe6, 0xed, 0x3c, 0xbd, 0x79, 0xf3, 0x26,
	0x86, 0x4e, 0x14, 0x6f, 0xe2, 0x22, 0xce, 0xd2, 0xab, 0x55, 0x9e, 0x95, 0x19, 0x6a, 0xfc, 0xc7,
	0xfc, 0xce, 0x40, 0x9d, 0x16, 0x94, 0x23, 0x82, 0x3a, 0x8d, 0xe2, 0xc8, 0x60, 0x03, 0x66, 0xb5,
	0x03, 0x5e, 0x63, 0x17, 0x94, 0x69, 0x1c, 0x19, 0xc7, 0x03, 0x66, 0x29, 0x41, 0x55, 0xa2, 0x01,
	0x27, 0x9f, 0x28, 0xaf, 0x64, 0x0c, 0x85, 0x13, 0x6b, 0x58, 0x75, 0x9c, 0x45, 0x98, 0xa6, 0xb4,
	0x34, 0x54, 0xd1, 0x91, 0x10, 0x2f, 0xa1, 0x35, 0xa2, 0x34, 0xa2, 0xdc, 0xd0, 0x06, 0xcc, 0xea,
	0xd8, 0x67, 0xc2, 0xc1, 0x95, 0x2b, 0x0d, 0x89, 0x66, 0x20, 0x49, 0xe6, 0x0c, 0x1e, 0x38, 0xd9,
	0x86, 0xf2, 0xba, 0x8d, 0x3d, 0xd0, 0xf8, 0x83, 0xb4, 0x26, 0x00, 0xbe, 0x02, 0xfd, 0x26, 0x2c,
	0x8a, 0x72, 0x91, 0x67, 0xeb, 0xf9, 0x82, 0x7b, 0xd4, 0xed, 0xfe, 0x2d, 0xe9, 0x1d, 0x46, 0xb0,
	0x4b, 0x37, 0x7f, 0x33, 0x78, 0x74, 0x80, 0x54, 0xcd, 0xf2, 0xbe, 0xae, 0xfc, 0x3a, 0x06, 0x01,
	0xb0, 0x0f, 0xa7, 0x6f, 0xd7, 0xb3, 0x2f, 0x54, 0xfa, 0x22, 0x8c, 0x76, 0xb0, 0xc5, 0xf8, 0x14,
	0x40, 0xd4, 0x1f, 0xc2, 0x84, 0x64, 0x28, 0x3b, 0x2f, 0x75, 0x86, 0x6a, 0x93, 0x61, 0x9d, 0xb4,
	0xb6, 0x93, 0x74, 0x0f, 0xb4, 0xe1, 0x72, 0xee, 0x47, 0x46, 0x4b, 0xcc, 0xe5, 0x00, 0xcf, 0xa1,
	0x3d, 0xa1, 0x7c, 0x43, 0x1f, 0xe3, 0x84, 0x8c, 0x13, 0xae, 0xd0, 0x3c, 0x98, 0x3f, 0x18, 0x9c,
	0xed, 0x25, 0x15, 0x50, 0xb1, 0xca, 0xd2, 0x82, 0xf0, 0x35, 0x74, 0xea, 0x7a, 0x52, 0x86, 0xe5,
	0xba, 0xe0, 0xeb, 0xdc, 0x4d, 0x5e, 0x34, 0x83, 0x5b, 0xe4, 0xea, 0x94, 0xe3, 0xb0, 0x28, 0xc2,
	0x39, 0xc9, 0x6d, 0x6b, 0x88, 0x16, 0xa8, 0x6e, 0x58, 0x86, 0x7c, 0x4d, 0xdd, 0xee, 0x49, 0xb9,
	0x7d, 0x13, 0x9c, 0x61, 0x7e, 0x63, 0x80, 0xe3, 0xf5, 0xb2, 0x8c, 0xf7, 0x6f, 0x59, 0xfd, 0x4b,
	0xb2, 0x24, 0x9e, 0xf9, 0x2e, 0xb7, 0xa4, 0x05, 0x35, 0x6c, 0xae, 0x7c, 0xfc, 0x97, 0x2b, 0x2b,
	0xff, 0x76, 0xe5, 0x5f, 0x0c, 0xfa, 0x77, 0x4d, 0xfc, 0xff, 0x98, 0x2e, 0xb7, 0x31, 0x29, 0x96,
	0x6e, 0x3f, 0x91, 0x72, 0x07, 0x9c, 0x70, 0xda, 0xc5, 0x0b, 0xe8, 0xec, 0x8f, 0x42, 0x1d, 0x4e,
	0x26, 0x53, 0xc7, 0xf1, 0x3c, 0xb7, 0x7b, 0x84, 0x00, 0xad, 0x77, 0x43, 0xff, 0xda, 0x73, 0xbb,
	0xec, 0xe2, 0x79, 0x43, 0x15, 0x9f, 0x0b, 0x9e, 0x82, 0x3a, 0x1e, 0x5e, 0x7b, 0x92, 0xe7, 0xf1,
	0x9a, 0xd9, 0x3f, 0x19, 0xe8, 0xdb, 0x29, 0x37, 0x0e, 0xbe, 0x81, 0x87, 0x23, 0x2a, 0xf9, 0xf0,
	0x80, 0x66, 0x59, 0x92, 0x50, 0x1a, 0xa1, 0x2e, 0x8d, 0x55, 0xdf, 0x7f, 0xff, 0xfc, 0xe0, 0x31,
	0xe5, 0xc6, 0xe6, 0x11, 0xbe, 0x87, 0xc7, 0x23, 0x2a, 0x9b, 0x1d, 0xee, 0x91, 0x79, 0x76, 0xff,
	0xb2, 0x5b, 0xad, 0xcf, 0x2d, 0xce, 0x79, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0x78, 0x2e, 0x66,
	0xf0, 0x94, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DivisionRPCClient is the client API for DivisionRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DivisionRPCClient interface {
	GetCoverRecommend(ctx context.Context, in *User, opts ...grpc.CallOption) (*CoverDivisionResponse, error)
	GetMultiCoverRecommend(ctx context.Context, in *User, opts ...grpc.CallOption) (*MultiCoverDivisionResponse, error)
}

type divisionRPCClient struct {
	cc *grpc.ClientConn
}

func NewDivisionRPCClient(cc *grpc.ClientConn) DivisionRPCClient {
	return &divisionRPCClient{cc}
}

func (c *divisionRPCClient) GetCoverRecommend(ctx context.Context, in *User, opts ...grpc.CallOption) (*CoverDivisionResponse, error) {
	out := new(CoverDivisionResponse)
	err := c.cc.Invoke(ctx, "/proto.DivisionRPC/GetCoverRecommend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *divisionRPCClient) GetMultiCoverRecommend(ctx context.Context, in *User, opts ...grpc.CallOption) (*MultiCoverDivisionResponse, error) {
	out := new(MultiCoverDivisionResponse)
	err := c.cc.Invoke(ctx, "/proto.DivisionRPC/GetMultiCoverRecommend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DivisionRPCServer is the server API for DivisionRPC service.
type DivisionRPCServer interface {
	GetCoverRecommend(context.Context, *User) (*CoverDivisionResponse, error)
	GetMultiCoverRecommend(context.Context, *User) (*MultiCoverDivisionResponse, error)
}

func RegisterDivisionRPCServer(s *grpc.Server, srv DivisionRPCServer) {
	s.RegisterService(&_DivisionRPC_serviceDesc, srv)
}

func _DivisionRPC_GetCoverRecommend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DivisionRPCServer).GetCoverRecommend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DivisionRPC/GetCoverRecommend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DivisionRPCServer).GetCoverRecommend(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _DivisionRPC_GetMultiCoverRecommend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DivisionRPCServer).GetMultiCoverRecommend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DivisionRPC/GetMultiCoverRecommend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DivisionRPCServer).GetMultiCoverRecommend(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

var _DivisionRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DivisionRPC",
	HandlerType: (*DivisionRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCoverRecommend",
			Handler:    _DivisionRPC_GetCoverRecommend_Handler,
		},
		{
			MethodName: "GetMultiCoverRecommend",
			Handler:    _DivisionRPC_GetMultiCoverRecommend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "division.proto",
}
